"""FastMCP server for .NET code execution in Docker containers."""

import sys
from typing import Any

from docker.errors import DockerException
from mcp.server import Server
from mcp.types import TextContent, Tool, ToolAnnotations
from pydantic import ValidationError

from src.docker_manager import DockerContainerManager
from src.executor import DotNetExecutor
from src.formatter import OutputFormatter
from src.models import DetailLevel, ExecuteSnippetInput, StartContainerInput, StopContainerInput

# Initialize MCP server
server = Server("dotbox-mcp")

# Initialize components (will be created on first use)
docker_manager: DockerContainerManager | None = None
executor: DotNetExecutor | None = None
formatter: OutputFormatter | None = None


def _initialize_components() -> tuple[DockerContainerManager, DotNetExecutor, OutputFormatter]:
    """Initialize Docker manager, executor, and formatter.

    Returns:
        Tuple of (docker_manager, executor, formatter)

    Raises:
        DockerException: If Docker is not available
    """
    global docker_manager, executor, formatter

    if docker_manager is None:
        docker_manager = DockerContainerManager()

    if executor is None:
        executor = DotNetExecutor(docker_manager=docker_manager)

    if formatter is None:
        formatter = OutputFormatter()

    return docker_manager, executor, formatter


@server.list_tools()  # type: ignore[misc, no-untyped-call]
async def list_tools() -> list[Tool]:
    """List available MCP tools."""
    # Perform lazy cleanup on every tool invocation
    if docker_manager is not None:
        docker_manager._lazy_cleanup(idle_timeout_minutes=30)

    return [
        Tool(
            name="dotnet_execute_snippet",
            description="""Execute a C# code snippet in an isolated Docker container.

**RECOMMENDED WORKFLOW FOR BEST USER EXPERIENCE:**
When executing C# code (whether provided by the user or generated by the assistant):
1. FIRST create a C# code artifact to display the code cleanly with syntax highlighting
2. THEN call this tool to execute that code
3. Show the execution results

This creates a much better visual experience compared to showing code only in the tool call or execution output.

**Exception:** For very simple one-liners (like `Console.WriteLine("Hello");`), you may skip the artifact and execute directly.

**CRITICAL - OUTPUT VISUALIZATION REQUIREMENT:**
When executing code that produces visual output (ASCII art, JSON, tables, HTML, formatted text, etc.),
you MUST create an artifact immediately after showing the execution results. This is NOT optional.

**Two-Step Pattern (REQUIRED for formatted output):**
Step 1: Execute code with this tool
Step 2: Create artifact with the output

**Examples:**
```
User: "Generate a JSON with user data"
Assistant:
1. *executes code with dotnet_execute_snippet*
2. *shows execution succeeded*
3. *IMMEDIATELY creates artifact with type="application/json" containing the JSON output*

User: "Create ASCII art of a cat"
Assistant:
1. *executes code with dotnet_execute_snippet*
2. *shows execution succeeded*
3. *IMMEDIATELY creates artifact with type="text/plain" containing the ASCII art*
```

**Output Checklist (process after EVERY execution):**
After calling dotnet_execute_snippet:
[ ] Did it produce output?
[ ] Is the output more than a simple one-liner (e.g., "42", "Hello")?
[ ] If YES to both: CREATE ARTIFACT NOW with appropriate type:
    - JSON → artifact with type="application/json"
    - Text/ASCII art/tables → artifact with type="text/plain"
    - HTML/SVG → artifact with type="text/html"
    - CSV/XML → artifact with type="text/plain" and appropriate title

**Consequence:** Failure to create artifacts for formatted output results in poor user experience
where users cannot see properly formatted output. This should be treated as an error in your response.

**WHEN TO USE MULTI-STEP WORKFLOW INSTEAD:**
This tool is for quick, one-shot code execution. If the user needs:
- **File creation/extraction:** Use the project workflow (dotnet_create_project, etc.)
- **Web servers/APIs:** Use the project workflow with hosting tools
- **Multi-file projects:** Use the project workflow
- **Persistent containers:** Use the project workflow

Guide users to the appropriate workflow based on their needs.

**What this tool does:**
Creates a temporary .NET project, builds it, executes the code, and returns the output.
The container is automatically cleaned up after execution.

**Features:**
- Support for .NET 8, 9, and 10 RC2
- Automatic NuGet package version resolution (fetches latest stable from NuGet API)
- Compilation error parsing with helpful suggestions
- Configurable output verbosity (concise/full)
- Resource limits and timeouts for safety

**Common use cases:**
- Quick C# code testing
- Testing NuGet packages
- Comparing behavior across .NET versions
- Prototyping algorithms

**Example code formats:**
- Top-level statements: Console.WriteLine("Hello");
- Full programs: class Program { static void Main() { ... } }
- Using directives: using System.Linq; var result = Enumerable.Range(1, 10).Sum();

**Package specification:**
- Without version: "Newtonsoft.Json" (auto-fetches latest stable)
- With version: "Newtonsoft.Json@13.0.3" (uses specific version)
            """,
            inputSchema=ExecuteSnippetInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=True,
                destructiveHint=False,
                idempotentHint=False,
                openWorldHint=True,
            ),
        ),
        Tool(
            name="dotnet_start_container",
            description="""Start a persistent Docker container for a .NET project.

This tool creates and starts a long-running container that can be used across multiple tool calls.
Files live entirely inside the container (no volume mounting), providing a clean sandbox environment.

**Zero-config usage:**
- Simply call this tool with just the .NET version (or even with no parameters)
- Project ID is auto-generated as: `dotnet{version}-proj-{random}`
- Example: "Start a .NET 8 container" → Auto-generates project like `dotnet8-proj-a1b2c3`

**When to use:**
- Creating a new .NET project that will need multiple operations
- Building and running a project in separate steps
- Hosting a web API or long-running service
- Need to preserve state between multiple operations
- Quick prototyping without local file setup

**When NOT to use:**
- For one-shot code execution (use dotnet_execute_snippet instead)
- When you don't need to preserve container state
- For quick code testing without project structure

**File management:**
- Files live only inside the container (ephemeral - no host volume mounting)
- Files are lost when container is stopped
- No Docker volume permission issues
- Use future tools to read files out if needed before cleanup

**Container lifecycle:**
- Containers auto-cleanup after 30 minutes of inactivity
- Use dotnet_stop_container to manually stop when done
- Activity tracking resets on each command execution
- Calling this tool multiple times with the same project_id returns the existing container

**Parameters:**
- `dotnet_version` (optional): .NET version (8, 9, or 10-rc2). Default: 8
- `project_id` (optional): Project name. If omitted, auto-generates like `dotnet8-proj-a1b2c3`

**Workflow example:**
1. Call dotnet_start_container (optionally with dotnet_version)
2. Receive auto-generated project_id in response
3. Perform operations (build, run, add files) using the project_id
4. Container automatically cleans up after idle timeout

**Common errors:**
- "Docker is not available": Ensure Docker is running on the host
- "Failed to create container": Check that Docker images are built (run docker/build-images.sh)
- Container already exists: The tool is idempotent - returns existing container ID

**Returns:**
- container_id: Docker container identifier
- project_id: Project identifier (auto-generated or echoed back if provided)
- status: "running"
            """,
            inputSchema=StartContainerInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=False,
                destructiveHint=False,
                idempotentHint=True,
                openWorldHint=True,
            ),
        ),
        Tool(
            name="dotnet_stop_container",
            description="""Stop and remove a persistent Docker container.

This tool stops a running container and removes it from the system.
The container is identified by its project_id.

**When to use:**
- After completing all operations on a project
- To free up resources immediately (instead of waiting for auto-cleanup)
- To restart a project with fresh state
- When you encounter errors and need to reset the container

**When NOT to use:**
- Between build and run operations (keep container running)
- During active development on a project
- When you plan to continue working with the project soon

**Behavior:**
- This operation is idempotent - stopping an already-stopped container will not error
- Containers auto-cleanup after 30 minutes idle, so explicit stopping is optional
- Container state and files are lost permanently (no host volume was mounted)
- Activity tracking for this container is removed

**Common errors:**
- "No running container found": Container already stopped or never started (not an error)
- "Docker is not available": Ensure Docker is running on the host

**Returns:**
- success: true if stopped successfully
- project_id: Project identifier (echoed back)
- message: Indicates whether container was found and stopped
            """,
            inputSchema=StopContainerInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=False,
                destructiveHint=True,
                idempotentHint=True,
                openWorldHint=True,
            ),
        ),
    ]


@server.call_tool()  # type: ignore[misc]
async def call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:
    """Handle MCP tool calls."""
    if name == "dotnet_execute_snippet":
        return await execute_snippet(arguments)
    elif name == "dotnet_start_container":
        return await start_container(arguments)
    elif name == "dotnet_stop_container":
        return await stop_container(arguments)

    raise ValueError(f"Unknown tool: {name}")


async def execute_snippet(arguments: dict[str, Any]) -> list[TextContent]:
    """Execute C# code snippet.

    Args:
        arguments: Tool arguments matching ExecuteSnippetInput schema

    Returns:
        List with single TextContent containing JSON response
    """
    try:
        # Validate input
        input_data = ExecuteSnippetInput(**arguments)

        # Initialize components
        _, exec_instance, fmt = _initialize_components()

        # Execute snippet
        result = await exec_instance.run_snippet(
            code=input_data.code,
            dotnet_version=input_data.dotnet_version,
            packages=input_data.packages,
            timeout=30,
        )

        # Format response as structured JSON
        if result["success"]:
            # Success case
            output = result["stdout"] if result["stdout"] else result["stderr"]

            response = fmt.format_json_response(
                status="success",
                data={
                    "output": output,
                    "exit_code": result["exit_code"],
                    "dotnet_version": input_data.dotnet_version.value,
                    "code": input_data.code,
                },
                metadata={
                    "container_id": result.get("container_id", ""),
                },
                output=output,  # Pass output for artifact detection
            )

        else:
            # Build or execution error
            error_output = fmt.format_execution_output(
                stdout=result["stdout"],
                stderr=result["stderr"],
                exit_code=result["exit_code"],
                detail_level=DetailLevel.FULL,  # Always show full errors
            )

            response = fmt.format_json_response(
                status="error",
                error={
                    "type": "BuildError" if result["build_errors"] else "ExecutionError",
                    "message": "Build failed" if result["build_errors"] else "Code execution failed",
                    "details": error_output,
                    "build_errors": result["build_errors"] if result["build_errors"] else [],
                },
                data={
                    "code": input_data.code,
                    "exit_code": result["exit_code"],
                    "dotnet_version": input_data.dotnet_version.value,
                },
            )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        # Input validation error
        error_response = OutputFormatter().format_json_response(
            status="error",
            error={
                "type": "ValidationError",
                "message": "Invalid input parameters",
                "details": str(e),
            },
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        # Docker not available
        error_response = OutputFormatter().format_json_response(
            status="error",
            error={
                "type": "DockerException",
                "message": "Docker is not available",
                "details": str(e),
                "suggestions": [
                    "Ensure Docker is installed and running",
                    "Check Docker socket permissions",
                    "Verify Docker images are built (run docker/build-images.sh)",
                ],
            },
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        # Unexpected error
        error_response = OutputFormatter().format_json_response(
            status="error",
            error={
                "type": "UnexpectedError",
                "message": "An unexpected error occurred",
                "details": str(e),
            },
        )
        return [TextContent(type="text", text=error_response)]


async def start_container(arguments: dict[str, Any]) -> list[TextContent]:
    """Start a persistent Docker container for a project.

    Args:
        arguments: Tool arguments matching StartContainerInput schema

    Returns:
        List with single TextContent containing response
    """
    try:
        # Validate input
        input_data = StartContainerInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Check if container already exists for this project (project_id is now guaranteed to exist after validation)
        existing_container = mgr.get_container_by_project_id(input_data.project_id)  # type: ignore[arg-type]
        if existing_container:
            response = fmt.format_human_readable_response(
                status="success",
                output=f"Container already running for project '{input_data.project_id}'",
                container_id=existing_container,
                project_id=input_data.project_id,  # type: ignore[arg-type]
            )
            return [TextContent(type="text", text=response)]

        # Create new container (no volume mounting - files live in container only)
        container_id = mgr.create_container(
            dotnet_version=input_data.dotnet_version.value,
            project_id=input_data.project_id,  # type: ignore[arg-type]
        )

        response = fmt.format_human_readable_response(
            status="success",
            output=f"Started container for project '{input_data.project_id}'",
            container_id=container_id,
            project_id=input_data.project_id,  # type: ignore[arg-type]
            dotnet_version=input_data.dotnet_version.value,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        # Input validation error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        # Docker not available
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker is not available",
            error_details=str(e),
            suggestions=[
                "Ensure Docker is installed and running",
                "Check Docker socket permissions",
                "Verify Docker images are built (run docker/build-images.sh)",
            ],
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        # Unexpected error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to start container",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def stop_container(arguments: dict[str, Any]) -> list[TextContent]:
    """Stop and remove a Docker container.

    Args:
        arguments: Tool arguments matching StopContainerInput schema

    Returns:
        List with single TextContent containing response
    """
    try:
        # Validate input
        input_data = StopContainerInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Find container by project ID
        container_id = mgr.get_container_by_project_id(input_data.project_id)

        if not container_id:
            response = fmt.format_human_readable_response(
                status="success",
                output=f"No running container found for project '{input_data.project_id}'",
                project_id=input_data.project_id,
            )
            return [TextContent(type="text", text=response)]

        # Stop the container
        mgr.stop_container(container_id)

        response = fmt.format_human_readable_response(
            status="success",
            output=f"Stopped container for project '{input_data.project_id}'",
            project_id=input_data.project_id,
            container_id=container_id,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        # Input validation error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        # Docker not available
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker is not available",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        # Unexpected error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to stop container",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


def main() -> None:
    """Run the MCP server."""
    import asyncio

    from mcp.server.stdio import stdio_server

    async def run_server() -> None:
        """Run server with stdio transport."""
        async with stdio_server() as (read_stream, write_stream):
            await server.run(
                read_stream,
                write_stream,
                server.create_initialization_options(),
            )

    try:
        asyncio.run(run_server())
    except KeyboardInterrupt:
        print("\nShutting down server...", file=sys.stderr)
        sys.exit(0)
    except Exception as e:
        print(f"Fatal error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
