"""FastMCP server for .NET code execution in Docker containers."""

import asyncio
import sys
from typing import Any

import httpx
from docker.errors import DockerException
from mcp.server import Server
from mcp.types import TextContent, Tool, ToolAnnotations
from pydantic import ValidationError

from src.docker_manager import DockerContainerManager
from src.executor import DotNetExecutor
from src.formatter import OutputFormatter
from src.models import (
    DetailLevel,
    ExecuteCommandInput,
    ExecuteSnippetInput,
    GetLogsInput,
    KillProcessInput,
    ListContainersInput,
    ListFilesInput,
    ReadFileInput,
    RunBackgroundInput,
    StartContainerInput,
    StopContainerInput,
    TestEndpointInput,
    WriteFileInput,
)

# Initialize MCP server
server = Server("dotbox-mcp")

# Initialize components (will be created on first use)
docker_manager: DockerContainerManager | None = None
executor: DotNetExecutor | None = None
formatter: OutputFormatter | None = None


def _initialize_components() -> tuple[DockerContainerManager, DotNetExecutor, OutputFormatter]:
    """Initialize Docker manager, executor, and formatter.

    Returns:
        Tuple of (docker_manager, executor, formatter)

    Raises:
        DockerException: If Docker is not available
    """
    global docker_manager, executor, formatter

    if docker_manager is None:
        docker_manager = DockerContainerManager()

    if executor is None:
        executor = DotNetExecutor(docker_manager=docker_manager)

    if formatter is None:
        formatter = OutputFormatter()

    return docker_manager, executor, formatter


@server.list_tools()  # type: ignore[misc, no-untyped-call]
async def list_tools() -> list[Tool]:
    """List available MCP tools."""
    # Perform lazy cleanup on every tool invocation
    if docker_manager is not None:
        docker_manager._lazy_cleanup(idle_timeout_minutes=30)

    return [
        Tool(
            name="dotnet_execute_snippet",
            description="""Execute a C# code snippet in an isolated Docker container.

**RECOMMENDED WORKFLOW FOR BEST USER EXPERIENCE:**
When executing C# code (whether provided by the user or generated by the assistant):
1. FIRST create a C# code artifact to display the code cleanly with syntax highlighting
2. THEN call this tool to execute that code
3. Show the execution results

This creates a much better visual experience compared to showing code only in the tool call or execution output.

**Exception:** For very simple one-liners (like `Console.WriteLine("Hello");`), you may skip the artifact and execute directly.

**CRITICAL - OUTPUT VISUALIZATION REQUIREMENT:**
When executing code that produces visual output (ASCII art, JSON, tables, HTML, formatted text, etc.),
you MUST create an artifact immediately after showing the execution results. This is NOT optional.

**Two-Step Pattern (REQUIRED for formatted output):**
Step 1: Execute code with this tool
Step 2: Create artifact with the output

**Examples:**
```
User: "Generate a JSON with user data"
Assistant:
1. *executes code with dotnet_execute_snippet*
2. *shows execution succeeded*
3. *IMMEDIATELY creates artifact with type="application/json" containing the JSON output*

User: "Create ASCII art of a cat"
Assistant:
1. *executes code with dotnet_execute_snippet*
2. *shows execution succeeded*
3. *IMMEDIATELY creates artifact with type="text/plain" containing the ASCII art*
```

**Output Checklist (process after EVERY execution):**
After calling dotnet_execute_snippet:
[ ] Did it produce output?
[ ] Is the output more than a simple one-liner (e.g., "42", "Hello")?
[ ] If YES to both: CREATE ARTIFACT NOW with appropriate type:
    - JSON → artifact with type="application/json"
    - Text/ASCII art/tables → artifact with type="text/plain"
    - HTML/SVG → artifact with type="text/html"
    - CSV/XML → artifact with type="text/plain" and appropriate title

**Consequence:** Failure to create artifacts for formatted output results in poor user experience
where users cannot see properly formatted output. This should be treated as an error in your response.

**WHEN TO USE MULTI-STEP WORKFLOW INSTEAD:**
This tool is for quick, one-shot code execution. If the user needs:
- **File creation/extraction:** Use the project workflow (dotnet_create_project, etc.)
- **Web servers/APIs:** Use the project workflow with hosting tools
- **Multi-file projects:** Use the project workflow
- **Persistent containers:** Use the project workflow

Guide users to the appropriate workflow based on their needs.

**What this tool does:**
Creates a temporary .NET project, builds it, executes the code, and returns the output.
The container is automatically cleaned up after execution.

**Features:**
- Support for .NET 8, 9, and 10 RC2
- Automatic NuGet package version resolution (fetches latest stable from NuGet API)
- Compilation error parsing with helpful suggestions
- Configurable output verbosity (concise/full)
- Resource limits and timeouts for safety

**Common use cases:**
- Quick C# code testing
- Testing NuGet packages
- Comparing behavior across .NET versions
- Prototyping algorithms

**Example code formats:**
- Top-level statements: Console.WriteLine("Hello");
- Full programs: class Program { static void Main() { ... } }
- Using directives: using System.Linq; var result = Enumerable.Range(1, 10).Sum();

**Package specification:**
- Without version: "Newtonsoft.Json" (auto-fetches latest stable)
- With version: "Newtonsoft.Json@13.0.3" (uses specific version)

**CRITICAL - Using External NuGet Packages:**
Before using any NuGet package (whether requested by user or chosen by you):
1. **ALWAYS search the web first** for current documentation and API usage
   - Use WebSearch to find: "[package name] C# latest documentation"
   - Check official docs, NuGet.org description, or GitHub README
   - Find recent code examples showing current API usage
2. **THEN write code** using the verified current API
3. Add the package to the packages parameter

**Why this matters:**
- Package APIs change between versions (breaking changes)
- Your training data may be outdated for specific packages
- Incorrect API usage wastes user time with compilation errors

**When to ALWAYS search:**
- Any external package beyond System.* namespaces
- Specialized libraries (HTTP clients, ORMs, cloud SDKs, ML, testing frameworks)
- If you're about to use a package and feel ANY uncertainty about the current API

**Example workflow:**
```
User: "Parse JSON with Newtonsoft.Json"
Assistant:
1. WebSearch("Newtonsoft.Json C# latest API example")
2. Review current JsonConvert.DeserializeObject usage
3. Write code with correct API
4. Execute with packages=["Newtonsoft.Json"]
```
            """,
            inputSchema=ExecuteSnippetInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=True,
                destructiveHint=False,
                idempotentHint=False,
                openWorldHint=True,
            ),
        ),
        Tool(
            name="dotnet_start_container",
            description="""Start a persistent Docker container for a .NET project.

This tool creates and starts a long-running container that can be used across multiple tool calls.
Files live entirely inside the container (no volume mounting), providing a clean sandbox environment.

**Container Capabilities:**
Containers include git, jq, sqlite3, and tree for advanced workflows:
- Clone and test existing GitHub repositories
- Parse JSON API responses with jq
- Query SQLite databases created by EF Core
- Visualize project structure with tree

Use dotnet_execute_command() to run these tools after starting a container.

**Zero-config usage:**
- Simply call this tool with just the .NET version (or even with no parameters)
- Project ID is auto-generated as: `dotnet{version}-proj-{random}`
- Example: "Start a .NET 8 container" → Auto-generates project like `dotnet8-proj-a1b2c3`

**When to use:**
- Creating a new .NET project that will need multiple operations
- Building and running a project in separate steps
- Hosting a web API or long-running service
- Need to preserve state between multiple operations
- Quick prototyping without local file setup

**When NOT to use:**
- For one-shot code execution (use dotnet_execute_snippet instead)
- When you don't need to preserve container state
- For quick code testing without project structure

**File management:**
- Files live only inside the container (ephemeral - no host volume mounting)
- Files are lost when container is stopped
- No Docker volume permission issues
- Use future tools to read files out if needed before cleanup

**Container lifecycle:**
- Containers auto-cleanup after 30 minutes of inactivity
- Use dotnet_stop_container to manually stop when done
- Activity tracking resets on each command execution
- Calling this tool multiple times with the same project_id returns the existing container

**Parameters:**
- `dotnet_version` (optional): .NET version (8, 9, or 10-rc2). Default: 8
- `project_id` (optional): Project name. If omitted, auto-generates like `dotnet8-proj-a1b2c3`
- `ports` (optional): Port mapping for exposing web servers/APIs to the host
  - **Format**: Object with container ports as keys, host ports as values
  - **Mental model**: `{"5000": 8080}` means:
    - Your .NET app listens on port **5000 INSIDE the container**
    - You access it at **http://localhost:8080 on your host machine**
    - Docker routes: host:8080 → container:5000 → your app
  - **Examples**:
    - Specific mapping: `{"5000": 8080}` - App listens on 5000, access via localhost:8080
    - Auto-assign: `{"5000": 0}` - Docker chooses an available host port (e.g., 32768)
    - Multiple ports: `{"5000": 8080, "5001": 8081}` - Two separate ports
  - **Access**: Use `dotnet_list_containers()` to see actual assigned host ports
  - **Default**: None (no ports exposed)

**IMPORTANT - Configuring your app's listening port:**
The container sets `ASPNETCORE_URLS=http://*:8080` by default. Your app must explicitly listen on your mapped container port:

**Method 1 - appsettings.json (recommended):**
```json
{
  "Kestrel": {
    "Endpoints": {
      "Http": { "Url": "http://0.0.0.0:5000" }
    }
  }
}
```

**Method 2 - Command line flag:**
```python
dotnet_run_background(
    command=["dotnet", "run", "--urls", "http://0.0.0.0:5000"]
)
```

**Example - Complete web API workflow:**
```python
# 1. Start container with port mapping
dotnet_start_container(dotnet_version=8, ports={"5000": 8080})

# 2. Create app that listens on port 5000 (matches container port)
dotnet_write_file(
    path="/workspace/api/appsettings.json",
    content='{"Kestrel": {"Endpoints": {"Http": {"Url": "http://0.0.0.0:5000"}}}}'
)

# 3. Access at http://localhost:8080 (the HOST port)
dotnet_test_endpoint(url="http://localhost:8080/health")
```

**Troubleshooting:**
- Can't reach API? Check `dotnet_get_logs()` to see which port it's actually listening on
- Seeing "Overriding address" warning? Your app config is correct, ignore the warning
- Port conflict? Use auto-assign (`{"5000": 0}`) instead of specific host ports

**Recommended Workflows:**

**Option A1 - Web API with external access (✅ RECOMMENDED):**
```python
# 1. Start container WITH port mapping (must decide upfront)
dotnet_start_container(dotnet_version=8, ports={"5000": 8080})

# 2. Create project using dotnet CLI
dotnet_execute_command(
    command=["dotnet", "new", "webapi", "-n", "MyApi", "-o", "/workspace/MyApi"]
)

# 3. Add packages if needed
dotnet_execute_command(
    command=["dotnet", "add", "/workspace/MyApi", "package", "Swashbuckle.AspNetCore"]
)

# 4. Configure app to listen on container port 5000
dotnet_write_file(
    path="/workspace/MyApi/appsettings.json",
    content='{"Kestrel": {"Endpoints": {"Http": {"Url": "http://0.0.0.0:5000"}}}}'
)

# 5. Run in background
dotnet_run_background(
    command=["dotnet", "run", "--project", "/workspace/MyApi"]
)

# 6. Access at http://localhost:8080
```

**Option A2 - Console app (no external access needed):**
```python
# 1. Start container WITHOUT ports (no external access)
dotnet_start_container(dotnet_version=8)

# 2. Create project using dotnet CLI
dotnet_execute_command(
    command=["dotnet", "new", "console", "-n", "MyApp", "-o", "/workspace/MyApp"]
)

# 3. Run directly
dotnet_execute_command(
    command=["dotnet", "run", "--project", "/workspace/MyApp"]
)
```

**Benefits of CLI-first approach:**
- ✅ Uses official .NET CLI tools (`dotnet new`, `dotnet add package`)
- ✅ Correct project structure guaranteed
- ✅ Standard .csproj format
- ✅ Idiomatic .NET workflow

**Option B - Manual file creation (for custom/minimal projects):**
```python
# Use when you need non-standard project structures or educational demos
dotnet_start_container(dotnet_version=8)
dotnet_write_file(path="/workspace/app/app.csproj", content="<Project>...")
dotnet_write_file(path="/workspace/app/Program.cs", content="...")
dotnet_execute_command(command=["dotnet", "build", "/workspace/app"])
```

**When to use each:**
- **Option A1**: Web APIs, HTTP services (needs external access)
- **Option A2**: Console apps, workers, batch jobs (internal only)
- **Option B**: Educational demos, minimal examples, non-standard structures

**Workflow example:**
1. Call dotnet_start_container (optionally with dotnet_version)
2. Receive auto-generated project_id in response
3. Perform operations (build, run, add files) using the project_id
4. Container automatically cleans up after idle timeout

**Common errors:**
- "Docker is not available": Ensure Docker is running on the host
- "Failed to create container": Check that Docker images are built (run docker/build-images.sh)
- Container already exists: The tool is idempotent - returns existing container ID

**Returns:**
- container_id: Docker container identifier
- project_id: Project identifier (auto-generated or echoed back if provided)
- status: "running"
            """,
            inputSchema=StartContainerInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=False,
                destructiveHint=False,
                idempotentHint=True,
                openWorldHint=True,
            ),
        ),
        Tool(
            name="dotnet_stop_container",
            description="""Stop and remove a persistent Docker container.

This tool stops a running container and removes it from the system.
The container is identified by its project_id.

**When to use:**
- After completing all operations on a project
- To free up resources immediately (instead of waiting for auto-cleanup)
- To restart a project with fresh state
- When you encounter errors and need to reset the container

**When NOT to use:**
- Between build and run operations (keep container running)
- During active development on a project
- When you plan to continue working with the project soon

**Behavior:**
- This operation is idempotent - stopping an already-stopped container will not error
- Containers auto-cleanup after 30 minutes idle, so explicit stopping is optional
- Container state and files are lost permanently (no host volume was mounted)
- Activity tracking for this container is removed

**Common errors:**
- "No running container found": Container already stopped or never started (not an error)
- "Docker is not available": Ensure Docker is running on the host

**Returns:**
- success: true if stopped successfully
- project_id: Project identifier (echoed back)
- message: Indicates whether container was found and stopped
            """,
            inputSchema=StopContainerInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=False,
                destructiveHint=True,
                idempotentHint=True,
                openWorldHint=True,
            ),
        ),
        Tool(
            name="dotnet_write_file",
            description="""Write a file to a persistent container.

**Purpose**: Create or update files in a running container for project development.

**For .NET Projects: Prefer dotnet CLI ✅**

For standard .NET projects, use `dotnet_execute_command` with CLI tools instead:
```python
# ✅ Recommended: Use dotnet CLI
dotnet_execute_command(command=["dotnet", "new", "webapi", "-n", "MyApi", "-o", "/workspace/MyApi"])

# ❌ Avoid: Manual .csproj creation (error-prone)
dotnet_write_file(path="/workspace/MyApi/MyApi.csproj", content="<Project>...")
```

**Use dotnet_write_file for:**
- Configuration files (appsettings.json, appsettings.Development.json)
- Custom source files after project creation
- Non-standard project scenarios
- Educational examples demonstrating specific concepts

**RECOMMENDED WORKFLOW FOR CODE FILES:**
When writing .NET code files (.cs, .csproj, etc.):
1. FIRST create an artifact to display the code with syntax highlighting
2. THEN call this tool to write that code to the container
3. Confirm the file was written successfully

This creates a much better visual experience for the user to review code before writing.

**Exception:** For simple config files or one-liners, you may skip the artifact.

**When to use**:
- Creating .NET project files (.csproj, Program.cs, etc.)
- Writing source code files
- Creating configuration files
- Building multi-file projects

**When NOT to use**:
- For one-shot code execution (use dotnet_execute_snippet instead)
- When container doesn't exist (start container first with dotnet_start_container)

**Security**:
- All paths must be within /workspace/ directory
- Directory traversal (..) is blocked
- Maximum file size: 100KB per file

**Example workflow**:
1. Start container: dotnet_start_container()
2. Show code in artifact, then write: dotnet_write_file(project_id, "/workspace/MyApp/MyApp.csproj", csproj_content)
3. Show code in artifact, then write: dotnet_write_file(project_id, "/workspace/MyApp/Program.cs", code)
4. Build: dotnet_execute_command(project_id, ["dotnet", "build", "/workspace/MyApp"])
5. Run: dotnet_execute_command(project_id, ["dotnet", "run", "--project", "/workspace/MyApp"])

**Returns**: Success message or error details
            """,
            inputSchema=WriteFileInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=False,
                destructiveHint=False,
                idempotentHint=True,
                openWorldHint=False,
            ),
        ),
        Tool(
            name="dotnet_read_file",
            description="""Read a file from a persistent container.

**Purpose**: Read file contents from a running container (source code, logs, output files).

**When to use**:
- Reading source code files
- Checking build output or logs
- Extracting generated files
- Debugging project structure

**When NOT to use**:
- When container doesn't exist
- For binary files (only text files supported)

**Security**:
- All paths must be within /workspace/ directory
- Directory traversal (..) is blocked

**Common use cases**:
- Read build logs after compilation
- Extract program output from files
- Verify file contents after writing
- Debug project configuration

**Returns**: File content as text or error if file doesn't exist
            """,
            inputSchema=ReadFileInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=True,
                destructiveHint=False,
                idempotentHint=True,
                openWorldHint=False,
            ),
        ),
        Tool(
            name="dotnet_list_files",
            description="""List files in a container directory.

**Purpose**: Explore directory contents in a running container.

**When to use**:
- Exploring project structure
- Verifying files were created
- Finding build artifacts
- Checking workspace contents

**When NOT to use**:
- When container doesn't exist
- For recursive directory listing (only lists immediate children)

**Security**:
- All paths must be within /workspace directory
- Directory traversal (..) is blocked

**Default behavior**:
- Lists /workspace if no path specified
- Shows files and subdirectories

**Returns**: List of file/directory names or empty list if directory doesn't exist
            """,
            inputSchema=ListFilesInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=True,
                destructiveHint=False,
                idempotentHint=True,
                openWorldHint=False,
            ),
        ),
        Tool(
            name="dotnet_execute_command",
            description="""Execute a command in a persistent container.

**Purpose**: Run arbitrary commands (dotnet build, dotnet run, shell commands) in a container.

**When to use**:
- Building .NET projects
- Running .NET applications
- Executing dotnet CLI commands
- Running shell commands for debugging

**When NOT to use**:
- For one-shot code execution (use dotnet_execute_snippet instead)
- When container doesn't exist
- For file operations (use dedicated file tools)

**Common .NET CLI commands**:

**Project Creation:**
- Web API: ["dotnet", "new", "webapi", "-n", "MyApi", "-o", "/workspace/MyApi"]
- Console app: ["dotnet", "new", "console", "-n", "MyApp", "-o", "/workspace/MyApp"]
- Class library: ["dotnet", "new", "classlib", "-n", "MyLib", "-o", "/workspace/MyLib"]

**Package Management:**
- Add latest: ["dotnet", "add", "/workspace/MyApi", "package", "Newtonsoft.Json"]
- Add specific version: ["dotnet", "add", "/workspace/MyApi", "package", "Dapper", "--version", "2.0.0"]
- List packages: ["dotnet", "list", "/workspace/MyApi", "package"]

**CRITICAL - Before Adding NuGet Packages:**
When adding any external NuGet package (whether user-requested or chosen by you):
1. **FIRST search the web** for current package documentation and API usage
2. Verify the correct namespace, class names, and method signatures
3. THEN add the package and write code with the verified current API

This prevents compilation errors from outdated API knowledge. See dotnet_execute_snippet for detailed guidance.

**Build & Run:**
- Build: ["dotnet", "build", "/workspace/MyApp"]
- Run: ["dotnet", "run", "--project", "/workspace/MyApp"]
- Run with args: ["dotnet", "run", "--project", "/workspace/MyApp", "--", "arg1", "arg2"]
- Test: ["dotnet", "test", "/workspace/MyApp"]

**Debugging:**
- List templates: ["dotnet", "new", "list"]
- Check version: ["dotnet", "--version"]
- List files: ["ls", "-la", "/workspace"]

**Enhanced Container Tools (Available in Sandbox):**
- **Git**: Clone repos and inspect history
  - ["git", "clone", "https://github.com/user/aspnet-project.git"]
  - ["git", "log", "--oneline", "-10"]
  - ["git", "diff", "HEAD~1"]
- **jq**: Parse JSON responses from APIs
  - ["sh", "-c", "curl -s http://localhost:5000/api/users | jq '.[]'"]
  - ["sh", "-c", "curl -s http://localhost:5000/api/data | jq '.items[] | {name, value}'"]
  - ["sh", "-c", "echo '{}' | jq empty"]  # Validate JSON
- **sqlite3**: Query SQLite databases (EF Core)
  - ["sqlite3", "/workspace/app.db", "SELECT * FROM Users LIMIT 10"]
  - ["sqlite3", "/workspace/app.db", ".schema Users"]
  - ["sqlite3", "/workspace/app.db", ".tables"]
- **tree**: Visualize project structure
  - ["tree", "/workspace", "-L", "2", "-I", "bin|obj"]
  - ["tree", "-d", "-L", "3"]  # Directories only

These tools enable workflows like testing existing GitHub projects, parsing API JSON responses,
inspecting EF Core database state, and understanding project organization.

**CRITICAL: Port Access Inside vs Outside Container:**

Commands executed via this tool run INSIDE the container. When accessing web endpoints:

- **From inside container** (this tool, curl, etc.): Use the CONTAINER port
  - Example: ["sh", "-c", "curl http://localhost:5000/api/health"]
  - The app listens on port 5000 inside the container, so use 5000

- **From outside container** (host machine, dotnet_test_endpoint): Use the HOST port
  - Example: dotnet_test_endpoint(url="http://localhost:8080/api/health")
  - Port mapping {"5000": 8080} means: container:5000 → host:8080

**Common mistake**: Using host port (8080) in curl commands inside container - this will fail!
- ❌ Wrong: ["sh", "-c", "curl http://localhost:8080/api"]  # 8080 doesn't exist inside
- ✅ Correct: ["sh", "-c", "curl http://localhost:5000/api"]  # 5000 is the app's port

**Timeout**:
- Default: 30 seconds
- Range: 1-300 seconds
- Adjust based on operation (builds may need 60+ seconds)

**Returns**:
- stdout: Command output
- stderr: Error output
- exit_code: 0 for success, non-zero for failure
            """,
            inputSchema=ExecuteCommandInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=False,
                destructiveHint=False,
                idempotentHint=False,
                openWorldHint=False,
            ),
        ),
        Tool(
            name="dotnet_run_background",
            description="""Run a long-running process in background (e.g., web server).

**Purpose**: Start long-running processes like web servers that need to keep running.

**When to use**:
- Starting web APIs or web applications
- Running background services
- Any process that runs continuously

**When NOT to use**:
- For short-lived commands (use dotnet_execute_command)
- For one-shot code execution (use dotnet_execute_snippet)

**Background execution**:
- Process runs in background using shell backgrounding (nohup)
- Tool returns immediately after wait_for_ready period
- Process continues running after tool returns
- Use dotnet_get_logs to check process output
- Process logs are available via container logs

**Common workflow**:
1. Start container with port mapping: dotnet_start_container(ports={5000: 8080})
2. Write project files: dotnet_write_file(...)
3. Start web server: dotnet_run_background(command=["dotnet", "run"])
4. Wait for ready (5 seconds default)
5. Test endpoint: dotnet_test_endpoint(url="http://localhost:8080/health")
6. Check logs if issues: dotnet_get_logs()

**Returns**: Success message with process start confirmation
            """,
            inputSchema=RunBackgroundInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=False,
                destructiveHint=False,
                idempotentHint=False,
                openWorldHint=True,
            ),
        ),
        Tool(
            name="dotnet_test_endpoint",
            description="""Test HTTP endpoints by making requests.

**Purpose**: Make HTTP requests to test web APIs and endpoints.

**When to use**:
- Testing web API endpoints
- Verifying server is responding
- Testing different HTTP methods (GET, POST, etc.)
- Checking API responses

**When NOT to use**:
- For executing C# code (use dotnet_execute_snippet)
- For checking if process is running (use dotnet_get_logs)

**Features**:
- Supports GET, POST, PUT, DELETE, PATCH methods
- Custom headers (authentication, content-type, etc.)
- Request body for POST/PUT
- Configurable timeout
- Returns status code, headers, and response body
- **Automatic localhost translation**: When MCP server runs in container, `localhost` is automatically translated to `host.docker.internal` for seamless access to host-mapped ports

**URL Handling**:
- Always use `localhost` in your URLs - translation happens automatically
- Example: `http://localhost:8080/health` works in all deployment modes (dev/docker/production)
- Port numbers should match the HOST port from `dotnet_start_container(ports={...})`

**Common use cases**:
- GET /health to check if API is ready: `dotnet_test_endpoint(url="http://localhost:8080/health")`
- POST /api/users with JSON body to test create endpoint
- GET /api/data to verify data endpoints
- Testing authentication with Authorization headers

**Returns**: HTTP response with status code, headers, and body
            """,
            inputSchema=TestEndpointInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=True,
                destructiveHint=False,
                idempotentHint=False,
                openWorldHint=True,
            ),
        ),
        Tool(
            name="dotnet_get_logs",
            description="""Retrieve container logs for debugging.

**Purpose**: Get logs from container to debug processes and see output.

**When to use**:
- Debugging background processes
- Checking web server startup logs
- Verifying process is running correctly
- Troubleshooting errors

**When NOT to use**:
- For reading file contents (use dotnet_read_file)
- For short-lived command output (use dotnet_execute_command)

**Log sources**:
- All stdout/stderr from processes in container
- dotnet run output
- Application logs
- Error messages and stack traces

**Parameters**:
- tail: Number of lines from end (default 50, max 1000)
- since: Only logs from last N seconds (optional)

**Common workflow**:
1. Start background process: dotnet_run_background(...)
2. Wait a few seconds
3. Check if started: dotnet_get_logs(tail=20)
4. Look for "Now listening on" or error messages

**Returns**: Container logs as text
            """,
            inputSchema=GetLogsInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=True,
                destructiveHint=False,
                idempotentHint=True,
                openWorldHint=False,
            ),
        ),
        Tool(
            name="dotnet_kill_process",
            description="""Kill background processes in a container.

**Purpose**: Stop long-running background processes (like web servers) without stopping the container.

**Use cases**:
- Stop a running web server to make code changes
- Kill stuck processes
- Clean up before restarting with new configuration
- Iterative development: run → test → kill → modify → run again

**Why use this instead of dotnet_stop_container**:
- Keeps container and files intact
- Faster than recreating container
- Preserves state for iterative development
- Can selectively kill specific processes

**Parameters**:
- process_pattern (optional): Specific process pattern to kill (e.g., "dotnet run --project MyApi")
- If omitted: Kills ALL background dotnet processes (safest default)

**Common workflows**:

1. **Iterative web development**:
   ```
   dotnet_run_background(...)  # Start server
   dotnet_test_endpoint(...)   # Test it
   # Want to make changes:
   dotnet_kill_process()       # Stop server
   dotnet_write_file(...)      # Update code
   dotnet_run_background(...)  # Restart server
   ```

2. **Selective process termination**:
   ```
   dotnet_kill_process(process_pattern="dotnet run --project Api1")  # Kill specific app
   ```

**Returns**: Success message if processes were killed, or message if no processes found
            """,
            inputSchema=KillProcessInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=False,
                destructiveHint=True,  # Kills processes
                idempotentHint=False,  # Different processes may be running each time
                openWorldHint=False,
            ),
        ),
        Tool(
            name="dotnet_list_containers",
            description="""List all active containers managed by this MCP server.

**Purpose**: Discover what containers are currently running, their ports, and status.

**When to use**:
- Discovering active projects when you've forgotten project_ids
- Checking which ports are mapped and available
- Resource monitoring (5 container limit)
- Debugging: "Why can't I access my API?" → Check actual port mapping
- Understanding current state before operations

**Information provided for each container**:
- project_id: The identifier used in other tools
- container_id: Docker container ID
- name: Human-readable container name
- status: Container status (running, paused, exited, etc.)
- ports: Port mappings (e.g., {"5000/tcp": "8080"} means container port 5000 → host port 8080)

**Common use cases**:

1. **Find forgotten project_id**:
   ```
   dotnet_list_containers()  # Shows all project_ids
   ```

2. **Check web server ports**:
   ```
   dotnet_list_containers()  # See which host port to connect to
   dotnet_test_endpoint(url="http://localhost:8080/health")
   ```

3. **Resource management**:
   ```
   dotnet_list_containers()  # Check how many containers running (max 5)
   ```

4. **Debugging port conflicts**:
   ```
   dotnet_list_containers()  # Verify expected ports are mapped
   ```

**No parameters required**: Lists ALL containers managed by this MCP server.

**Returns**: List of containers with their details (project_id, status, ports, etc.)
            """,
            inputSchema=ListContainersInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=True,  # Read-only operation
                destructiveHint=False,
                idempotentHint=True,  # Same containers will be listed each time
                openWorldHint=False,  # Closed world - only lists managed containers
            ),
        ),
    ]


@server.call_tool()  # type: ignore[misc]
async def call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:
    """Handle MCP tool calls."""
    if name == "dotnet_execute_snippet":
        return await execute_snippet(arguments)
    elif name == "dotnet_start_container":
        return await start_container(arguments)
    elif name == "dotnet_stop_container":
        return await stop_container(arguments)
    elif name == "dotnet_write_file":
        return await write_file(arguments)
    elif name == "dotnet_read_file":
        return await read_file(arguments)
    elif name == "dotnet_list_files":
        return await list_files(arguments)
    elif name == "dotnet_execute_command":
        return await execute_command(arguments)
    elif name == "dotnet_run_background":
        return await run_background(arguments)
    elif name == "dotnet_test_endpoint":
        return await test_endpoint(arguments)
    elif name == "dotnet_get_logs":
        return await get_logs(arguments)
    elif name == "dotnet_kill_process":
        return await kill_process(arguments)
    elif name == "dotnet_list_containers":
        return await list_containers(arguments)

    raise ValueError(f"Unknown tool: {name}")


def _running_in_container() -> bool:
    """Detect if the MCP server is running inside a Docker container.

    Returns:
        True if running in container, False otherwise
    """
    import os
    return os.path.exists("/.dockerenv") or os.path.exists("/run/.containerenv")


def _translate_localhost_url(url: str) -> str:
    """Translate localhost URLs to host.docker.internal when running in container.

    This enables the MCP server (running in a container) to access sandbox containers
    whose ports are mapped to the host machine.

    Args:
        url: Original URL (may contain localhost or 127.0.0.1)

    Returns:
        Translated URL with host.docker.internal if running in container
    """
    if _running_in_container():
        url = url.replace("localhost", "host.docker.internal")
        url = url.replace("127.0.0.1", "host.docker.internal")
    return url


async def execute_snippet(arguments: dict[str, Any]) -> list[TextContent]:
    """Execute C# code snippet.

    Args:
        arguments: Tool arguments matching ExecuteSnippetInput schema

    Returns:
        List with single TextContent containing JSON response
    """
    try:
        # Validate input
        input_data = ExecuteSnippetInput(**arguments)

        # Initialize components
        _, exec_instance, fmt = _initialize_components()

        # Execute snippet
        result = await exec_instance.run_snippet(
            code=input_data.code,
            dotnet_version=input_data.dotnet_version,
            packages=input_data.packages,
            timeout=30,
        )

        # Format response as structured JSON
        if result["success"]:
            # Success case
            output = result["stdout"] if result["stdout"] else result["stderr"]

            response = fmt.format_json_response(
                status="success",
                data={
                    "output": output,
                    "exit_code": result["exit_code"],
                    "dotnet_version": input_data.dotnet_version.value,
                    "code": input_data.code,
                },
                metadata={
                    "container_id": result.get("container_id", ""),
                },
                output=output,  # Pass output for artifact detection
            )

        else:
            # Build or execution error
            error_output = fmt.format_execution_output(
                stdout=result["stdout"],
                stderr=result["stderr"],
                exit_code=result["exit_code"],
                detail_level=DetailLevel.FULL,  # Always show full errors
            )

            response = fmt.format_json_response(
                status="error",
                error={
                    "type": "BuildError" if result["build_errors"] else "ExecutionError",
                    "message": "Build failed" if result["build_errors"] else "Code execution failed",
                    "details": error_output,
                    "build_errors": result["build_errors"] if result["build_errors"] else [],
                },
                data={
                    "code": input_data.code,
                    "exit_code": result["exit_code"],
                    "dotnet_version": input_data.dotnet_version.value,
                },
            )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        # Input validation error
        error_response = OutputFormatter().format_json_response(
            status="error",
            error={
                "type": "ValidationError",
                "message": "Invalid input parameters",
                "details": str(e),
            },
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        # Docker not available
        error_response = OutputFormatter().format_json_response(
            status="error",
            error={
                "type": "DockerException",
                "message": "Docker is not available",
                "details": str(e),
                "suggestions": [
                    "Ensure Docker is installed and running",
                    "Check Docker socket permissions",
                    "Verify Docker images are built (run docker/build-images.sh)",
                ],
            },
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        # Unexpected error
        error_response = OutputFormatter().format_json_response(
            status="error",
            error={
                "type": "UnexpectedError",
                "message": "An unexpected error occurred",
                "details": str(e),
            },
        )
        return [TextContent(type="text", text=error_response)]


async def start_container(arguments: dict[str, Any]) -> list[TextContent]:
    """Start a persistent Docker container for a project.

    Args:
        arguments: Tool arguments matching StartContainerInput schema

    Returns:
        List with single TextContent containing response
    """
    try:
        # Validate input
        input_data = StartContainerInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Check if container already exists for this project (project_id is now guaranteed to exist after validation)
        existing_container = mgr.get_container_by_project_id(input_data.project_id)  # type: ignore[arg-type]
        if existing_container:
            response = fmt.format_human_readable_response(
                status="success",
                output=f"Container already running for project '{input_data.project_id}'",
                container_id=existing_container,
                project_id=input_data.project_id,  # type: ignore[arg-type]
            )
            return [TextContent(type="text", text=response)]

        # Create new container (no volume mounting - files live in container only)
        container_id = mgr.create_container(
            dotnet_version=input_data.dotnet_version.value,
            project_id=input_data.project_id,  # type: ignore[arg-type]
            port_mapping=input_data.ports,
        )

        # Get port information if ports were mapped
        port_info = {}
        if input_data.ports:
            # Get actual mapped ports from container
            containers = mgr.list_containers()
            for container in containers:
                if container.container_id == container_id:
                    port_info = container.ports
                    break

        # Build output message
        output_msg = f"Started container for project '{input_data.project_id}'"
        if port_info:
            port_list = [f"{container_port} → {host_port}" for container_port, host_port in port_info.items()]
            output_msg += f"\nPorts: {', '.join(port_list)}"

        response = fmt.format_human_readable_response(
            status="success",
            output=output_msg,
            container_id=container_id,
            project_id=input_data.project_id,  # type: ignore[arg-type]
            dotnet_version=input_data.dotnet_version.value,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        # Input validation error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        # Check if this is a port conflict error (must check before generic Docker error)
        error_msg = str(e).lower()
        is_port_conflict = any(
            phrase in error_msg
            for phrase in [
                "address already in use",
                "bind: address already in use",
                "port is already allocated",
                "failed to set up container networking",
            ]
        )

        if is_port_conflict and input_data.ports:
            # Port conflict - provide actionable suggestions to LLM
            # Build auto-assign example
            auto_ports = ', '.join(f"'{cp}': 0" for cp in input_data.ports.keys())

            error_response = OutputFormatter().format_human_readable_response(
                status="error",
                error_message="Port conflict: One or more requested ports are already in use",
                error_details=str(e),
                suggestions=[
                    f"Use auto-assigned ports instead: dotnet_start_container(project_id='{input_data.project_id}', ports={{{auto_ports}}})",
                    "Check which containers are using the port: dotnet_list_containers()",
                    "Stop the conflicting container if no longer needed",
                    "Use different host ports that are not occupied",
                ],
            )
        else:
            # Generic Docker error (daemon not running, image not found, etc.)
            error_response = OutputFormatter().format_human_readable_response(
                status="error",
                error_message="Docker error",
                error_details=str(e),
                suggestions=[
                    "Ensure Docker is installed and running",
                    "Check Docker socket permissions",
                    "Verify Docker images are built (run docker/build-images.sh)",
                ],
            )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        # Other unexpected error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to start container",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def stop_container(arguments: dict[str, Any]) -> list[TextContent]:
    """Stop and remove a Docker container.

    Args:
        arguments: Tool arguments matching StopContainerInput schema

    Returns:
        List with single TextContent containing response
    """
    try:
        # Validate input
        input_data = StopContainerInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Find container by project ID
        container_id = mgr.get_container_by_project_id(input_data.project_id)

        if not container_id:
            response = fmt.format_human_readable_response(
                status="success",
                output=f"No running container found for project '{input_data.project_id}'",
                project_id=input_data.project_id,
            )
            return [TextContent(type="text", text=response)]

        # Stop the container
        mgr.stop_container(container_id)

        response = fmt.format_human_readable_response(
            status="success",
            output=f"Stopped container for project '{input_data.project_id}'",
            project_id=input_data.project_id,
            container_id=container_id,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        # Input validation error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        # Docker not available
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker is not available",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        # Unexpected error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to stop container",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def write_file(arguments: dict[str, Any]) -> list[TextContent]:
    """Write a file to a container.

    Args:
        arguments: Tool arguments matching WriteFileInput schema

    Returns:
        List with single TextContent containing response
    """
    try:
        # Validate input
        input_data = WriteFileInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Find container by project ID
        container_id = mgr.get_container_by_project_id(input_data.project_id)

        if not container_id:
            response = fmt.format_human_readable_response(
                status="error",
                error_message=f"No running container found for project '{input_data.project_id}'",
                error_details="Start a container first with dotnet_start_container",
            )
            return [TextContent(type="text", text=response)]

        # Write file to container
        mgr.write_file(
            container_id=container_id,
            dest_path=input_data.path,
            content=input_data.content,
        )

        response = fmt.format_human_readable_response(
            status="success",
            output=f"File written successfully to {input_data.path}",
            project_id=input_data.project_id,
            container_id=container_id,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker operation failed",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to write file",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def read_file(arguments: dict[str, Any]) -> list[TextContent]:
    """Read a file from a container.

    Args:
        arguments: Tool arguments matching ReadFileInput schema

    Returns:
        List with single TextContent containing file content or error
    """
    try:
        # Validate input
        input_data = ReadFileInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Find container by project ID
        container_id = mgr.get_container_by_project_id(input_data.project_id)

        if not container_id:
            response = fmt.format_human_readable_response(
                status="error",
                error_message=f"No running container found for project '{input_data.project_id}'",
                error_details="Start a container first with dotnet_start_container",
            )
            return [TextContent(type="text", text=response)]

        # Read file from container
        try:
            content_bytes = mgr.read_file(
                container_id=container_id,
                path=input_data.path,
            )
            content = content_bytes.decode("utf-8")

            response = fmt.format_human_readable_response(
                status="success",
                output=content,
                project_id=input_data.project_id,
            )

            return [TextContent(type="text", text=response)]

        except FileNotFoundError:
            error_response = fmt.format_human_readable_response(
                status="error",
                error_message=f"File not found: {input_data.path}",
                error_details="Check the path and try again",
            )
            return [TextContent(type="text", text=error_response)]

    except ValidationError as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker operation failed",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to read file",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def list_files(arguments: dict[str, Any]) -> list[TextContent]:
    """List files in a container directory.

    Args:
        arguments: Tool arguments matching ListFilesInput schema

    Returns:
        List with single TextContent containing file list or error
    """
    try:
        # Validate input
        input_data = ListFilesInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Find container by project ID
        container_id = mgr.get_container_by_project_id(input_data.project_id)

        if not container_id:
            response = fmt.format_human_readable_response(
                status="error",
                error_message=f"No running container found for project '{input_data.project_id}'",
                error_details="Start a container first with dotnet_start_container",
            )
            return [TextContent(type="text", text=response)]

        # List files in directory
        files = mgr.list_files(
            container_id=container_id,
            path=input_data.path,
        )

        if not files:
            output = f"Directory is empty or does not exist: {input_data.path}"
        else:
            output = f"Files in {input_data.path}:\n" + "\n".join(f"  {f}" for f in files)

        response = fmt.format_human_readable_response(
            status="success",
            output=output,
            project_id=input_data.project_id,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker operation failed",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to list files",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def execute_command(arguments: dict[str, Any]) -> list[TextContent]:
    """Execute a command in a container.

    Args:
        arguments: Tool arguments matching ExecuteCommandInput schema

    Returns:
        List with single TextContent containing command output or error
    """
    try:
        # Validate input
        input_data = ExecuteCommandInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Find container by project ID
        container_id = mgr.get_container_by_project_id(input_data.project_id)

        if not container_id:
            response = fmt.format_human_readable_response(
                status="error",
                error_message=f"No running container found for project '{input_data.project_id}'",
                error_details="Start a container first with dotnet_start_container",
            )
            return [TextContent(type="text", text=response)]

        # Execute command
        stdout, stderr, exit_code = mgr.execute_command(
            container_id=container_id,
            command=input_data.command,
            timeout=input_data.timeout,
        )

        # Format output
        output_lines = []
        output_lines.append(f"Command: {' '.join(input_data.command)}")
        output_lines.append(f"Exit code: {exit_code}")

        if stdout:
            output_lines.append(f"\nStdout:\n{stdout}")

        if stderr:
            output_lines.append(f"\nStderr:\n{stderr}")

        output = "\n".join(output_lines)

        # CRITICAL: Pass output to error_details when command fails
        # The formatter's error path doesn't display the 'output' parameter,
        # so we must pass stdout/stderr via error_details to make them visible
        if exit_code == 0:
            # Success: use normal output parameter
            response = fmt.format_human_readable_response(
                status="success",
                output=output,
                project_id=input_data.project_id,
                container_id=container_id,
            )
        else:
            # Failure: pass output to error_details so it's visible
            response = fmt.format_human_readable_response(
                status="error",
                error_message=f"Command failed with exit code {exit_code}",
                error_details=output,
                project_id=input_data.project_id,
                container_id=container_id,
            )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker operation failed",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to execute command",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def run_background(arguments: dict[str, Any]) -> list[TextContent]:
    """Run a command in background (long-running process).

    Args:
        arguments: Tool arguments matching RunBackgroundInput schema

    Returns:
        List with single TextContent containing response
    """
    try:
        # Validate input
        input_data = RunBackgroundInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Find container by project ID
        container_id = mgr.get_container_by_project_id(input_data.project_id)

        if not container_id:
            response = fmt.format_human_readable_response(
                status="error",
                error_message=f"No running container found for project '{input_data.project_id}'",
                error_details="Start a container first with dotnet_start_container",
            )
            return [TextContent(type="text", text=response)]

        # Build background command using nohup and shell backgrounding
        # Output redirected to container stdout/stderr (accessible via logs)
        command_str = " ".join(input_data.command)
        bg_command = ["sh", "-c", f"nohup {command_str} </dev/null >/proc/1/fd/1 2>/proc/1/fd/2 &"]

        # Execute background command
        stdout, stderr, exit_code = mgr.execute_command(
            container_id=container_id,
            command=bg_command,
            timeout=5,
        )

        # Wait for process to start
        if input_data.wait_for_ready > 0:
            import asyncio
            await asyncio.sleep(input_data.wait_for_ready)

        # Check if process started successfully
        response = fmt.format_human_readable_response(
            status="success",
            output=f"Process started in background: {' '.join(input_data.command)}\nWaited {input_data.wait_for_ready} seconds for startup.\nUse dotnet_get_logs to check process output.",
            project_id=input_data.project_id,
            container_id=container_id,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker operation failed",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to run background process",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def test_endpoint(arguments: dict[str, Any]) -> list[TextContent]:
    """Test an HTTP endpoint.

    Args:
        arguments: Tool arguments matching TestEndpointInput schema

    Returns:
        List with single TextContent containing response
    """
    try:
        # Validate input
        input_data = TestEndpointInput(**arguments)

        # Initialize formatter
        _, _, fmt = _initialize_components()

        # Translate localhost → host.docker.internal when MCP server runs in container
        # This allows the MCP container to access sandbox containers via host ports
        url = _translate_localhost_url(input_data.url)

        # Make HTTP request using httpx
        import time
        start_time = time.time()

        async with httpx.AsyncClient(timeout=input_data.timeout) as client:
            # Make request with explicit arguments for type safety
            # Only pass headers if not empty (httpx handles None differently than {})
            headers = input_data.headers if input_data.headers else None

            if input_data.body and input_data.method in ["POST", "PUT", "PATCH"]:
                response = await client.request(
                    input_data.method,
                    url,
                    headers=headers,
                    content=input_data.body,
                )
            else:
                response = await client.request(
                    input_data.method,
                    url,
                    headers=headers,
                )

        response_time_ms = int((time.time() - start_time) * 1000)

        # Format response
        output = f"""HTTP {input_data.method} {input_data.url}
Status: {response.status_code} {response.reason_phrase}
Response Time: {response_time_ms}ms

Headers:
{chr(10).join(f'  {k}: {v}' for k, v in response.headers.items())}

Body:
{response.text}"""

        result = fmt.format_human_readable_response(
            status="success" if 200 <= response.status_code < 400 else "error",
            output=output,
        )

        return [TextContent(type="text", text=result)]

    except ValidationError as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except httpx.TimeoutException:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message=f"Request timed out after {input_data.timeout} seconds",
            error_details=f"Could not connect to {input_data.url}",
            suggestions=[
                "Check if the server is running",
                "Verify the port mapping is correct",
                "Use dotnet_get_logs to check server startup",
                "Increase timeout if server is slow to start",
            ],
        )
        return [TextContent(type="text", text=error_response)]

    except httpx.ConnectError as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Connection refused",
            error_details=str(e),
            suggestions=[
                "Check if the server is running: dotnet_get_logs",
                "Verify the URL and port are correct",
                "Ensure port mapping was configured: dotnet_start_container(ports={...})",
                "Wait a bit longer for server to start",
            ],
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="HTTP request failed",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def get_logs(arguments: dict[str, Any]) -> list[TextContent]:
    """Get container logs.

    Args:
        arguments: Tool arguments matching GetLogsInput schema

    Returns:
        List with single TextContent containing logs
    """
    try:
        # Validate input
        input_data = GetLogsInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Find container by project ID
        container_id = mgr.get_container_by_project_id(input_data.project_id)

        if not container_id:
            response = fmt.format_human_readable_response(
                status="error",
                error_message=f"No running container found for project '{input_data.project_id}'",
                error_details="Start a container first with dotnet_start_container",
            )
            return [TextContent(type="text", text=response)]

        # Get logs from container
        logs = mgr.get_container_logs(
            container_id=container_id,
            tail=input_data.tail,
            since=input_data.since,
        )

        if not logs:
            output = "No logs available (container may have just started)"
        else:
            output = f"Container logs (last {input_data.tail} lines):\n\n{logs}"

        response = fmt.format_human_readable_response(
            status="success",
            output=output,
            project_id=input_data.project_id,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker operation failed",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to get logs",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def kill_process(arguments: dict[str, Any]) -> list[TextContent]:
    """Kill background processes in a container.

    Args:
        arguments: Tool arguments matching KillProcessInput schema

    Returns:
        List with single TextContent containing result
    """
    try:
        # Validate input
        input_data = KillProcessInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Find container by project ID
        container_id = mgr.get_container_by_project_id(input_data.project_id)

        if not container_id:
            response = fmt.format_human_readable_response(
                status="error",
                error_message=f"No running container found for project '{input_data.project_id}'",
                error_details="Start a container first with dotnet_start_container",
            )
            return [TextContent(type="text", text=response)]

        # Build pkill command based on pattern
        if input_data.process_pattern:
            # Kill processes matching specific pattern
            command = ["pkill", "-f", input_data.process_pattern]
            desc = f"processes matching '{input_data.process_pattern}'"
        else:
            # Kill all background dotnet processes (common use case)
            command = ["pkill", "-f", "dotnet"]
            desc = "background dotnet processes"

        # Execute kill command (pkill returns 0 if processes were killed, 1 if none found)
        stdout, stderr, exit_code = mgr.execute_command(
            container_id=container_id,
            command=command,
            timeout=5,
        )

        if exit_code == 0:
            output = f"Successfully killed {desc} in container '{input_data.project_id}'"
        elif exit_code == 1:
            output = f"No {desc} found running in container '{input_data.project_id}'"
        else:
            output = f"Kill command completed with exit code {exit_code}\nStderr: {stderr}"

        response = fmt.format_human_readable_response(
            status="success",
            output=output,
            project_id=input_data.project_id,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker operation failed",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to kill processes",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def list_containers(arguments: dict[str, Any]) -> list[TextContent]:
    """List all active containers managed by this MCP server.

    Args:
        arguments: Tool arguments (empty - no parameters required)

    Returns:
        List with single TextContent containing container list or error
    """
    try:
        # Validate input (should be empty dict)
        ListContainersInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Get all managed containers
        containers = mgr.list_containers()

        if not containers:
            response = fmt.format_human_readable_response(
                status="success",
                output="No active containers found. Start a container with dotnet_start_container.",
            )
            return [TextContent(type="text", text=response)]

        # Format container information
        output_lines = [f"Found {len(containers)} active container(s):"]
        output_lines.append("")

        for idx, container in enumerate(containers, 1):
            output_lines.append(f"{idx}. Project: {container.project_id}")
            output_lines.append(f"   Container ID: {container.container_id[:12]}")
            output_lines.append(f"   Name: {container.name}")
            output_lines.append(f"   Status: {container.status}")

            if container.ports:
                output_lines.append("   Port Mappings:")
                for container_port, host_port in container.ports.items():
                    output_lines.append(f"     - Container {container_port} → Host {host_port}")
            else:
                output_lines.append("   Port Mappings: None")

            output_lines.append("")

        output = "\n".join(output_lines)

        response = fmt.format_human_readable_response(
            status="success",
            output=output,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker operation failed",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to list containers",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def background_cleanup_task(interval_seconds: int = 300) -> None:
    """Run periodic container cleanup.

    Args:
        interval_seconds: Cleanup interval in seconds (default: 300 = 5 minutes)
    """
    global docker_manager

    while True:
        try:
            await asyncio.sleep(interval_seconds)
            if docker_manager is not None:
                count = docker_manager._lazy_cleanup(idle_timeout_minutes=30)
                if count > 0:
                    print(f"Background cleanup: removed {count} idle container(s)", file=sys.stderr)
        except asyncio.CancelledError:
            print("Background cleanup task cancelled", file=sys.stderr)
            raise
        except Exception as e:
            print(f"Background cleanup error: {e}", file=sys.stderr)
            # Continue running despite errors


def cleanup_all_containers() -> None:
    """Clean up all containers on server shutdown."""
    global docker_manager

    if docker_manager is not None:
        try:
            count = docker_manager.cleanup_all()
            try:
                print(f"Shutdown cleanup: removed {count} container(s)", file=sys.stderr)
            except (BrokenPipeError, OSError):
                pass  # Ignore pipe errors during logging
        except Exception as e:
            # Log the actual error so we can debug
            try:
                print(f"Shutdown cleanup FAILED: {type(e).__name__}: {e}", file=sys.stderr)
                import traceback
                traceback.print_exc(file=sys.stderr)
            except (BrokenPipeError, OSError):
                pass  # If we can't log, continue anyway


def main() -> None:
    """Run the MCP server."""
    from mcp.server.stdio import stdio_server

    async def run_server() -> None:
        """Run server with stdio transport and background cleanup."""
        # Initialize docker_manager first so cleanup can work
        global docker_manager
        if docker_manager is None:
            try:
                docker_manager = DockerContainerManager()
            except Exception as e:
                print(f"Failed to initialize Docker: {e}", file=sys.stderr)

        # Clean up any zombie containers from previous sessions on startup
        try:
            print("Checking for zombie containers from previous sessions...", file=sys.stderr)
        except (BrokenPipeError, OSError):
            pass  # Pipes may already be closed
        cleanup_all_containers()

        # Start background cleanup task
        cleanup_task = asyncio.create_task(background_cleanup_task(interval_seconds=300))

        try:
            async with stdio_server() as (read_stream, write_stream):
                await server.run(
                    read_stream,
                    write_stream,
                    server.create_initialization_options(),
                )
        finally:
            # Cancel background task
            cleanup_task.cancel()
            try:
                await cleanup_task
            except asyncio.CancelledError:
                pass

            # CRITICAL: Clean up all containers on shutdown
            try:
                print("\nCleaning up containers on shutdown...", file=sys.stderr)
            except (BrokenPipeError, OSError):
                pass
            cleanup_all_containers()

    try:
        asyncio.run(run_server())
    except KeyboardInterrupt:
        print("\nShutting down server...", file=sys.stderr)
        cleanup_all_containers()
        sys.exit(0)
    except Exception as e:
        print(f"Fatal error: {e}", file=sys.stderr)
        cleanup_all_containers()
        sys.exit(1)


if __name__ == "__main__":
    main()
