"""FastMCP server for .NET code execution in Docker containers."""

import sys
from typing import Any

from docker.errors import DockerException
from mcp.server import Server
from mcp.types import TextContent, Tool, ToolAnnotations
from pydantic import ValidationError

from src.docker_manager import DockerContainerManager
from src.executor import DotNetExecutor
from src.formatter import OutputFormatter
from src.models import (
    DetailLevel,
    ExecuteCommandInput,
    ExecuteSnippetInput,
    ListFilesInput,
    ReadFileInput,
    StartContainerInput,
    StopContainerInput,
    WriteFileInput,
)

# Initialize MCP server
server = Server("dotbox-mcp")

# Initialize components (will be created on first use)
docker_manager: DockerContainerManager | None = None
executor: DotNetExecutor | None = None
formatter: OutputFormatter | None = None


def _initialize_components() -> tuple[DockerContainerManager, DotNetExecutor, OutputFormatter]:
    """Initialize Docker manager, executor, and formatter.

    Returns:
        Tuple of (docker_manager, executor, formatter)

    Raises:
        DockerException: If Docker is not available
    """
    global docker_manager, executor, formatter

    if docker_manager is None:
        docker_manager = DockerContainerManager()

    if executor is None:
        executor = DotNetExecutor(docker_manager=docker_manager)

    if formatter is None:
        formatter = OutputFormatter()

    return docker_manager, executor, formatter


@server.list_tools()  # type: ignore[misc, no-untyped-call]
async def list_tools() -> list[Tool]:
    """List available MCP tools."""
    # Perform lazy cleanup on every tool invocation
    if docker_manager is not None:
        docker_manager._lazy_cleanup(idle_timeout_minutes=30)

    return [
        Tool(
            name="dotnet_execute_snippet",
            description="""Execute a C# code snippet in an isolated Docker container.

**RECOMMENDED WORKFLOW FOR BEST USER EXPERIENCE:**
When executing C# code (whether provided by the user or generated by the assistant):
1. FIRST create a C# code artifact to display the code cleanly with syntax highlighting
2. THEN call this tool to execute that code
3. Show the execution results

This creates a much better visual experience compared to showing code only in the tool call or execution output.

**Exception:** For very simple one-liners (like `Console.WriteLine("Hello");`), you may skip the artifact and execute directly.

**CRITICAL - OUTPUT VISUALIZATION REQUIREMENT:**
When executing code that produces visual output (ASCII art, JSON, tables, HTML, formatted text, etc.),
you MUST create an artifact immediately after showing the execution results. This is NOT optional.

**Two-Step Pattern (REQUIRED for formatted output):**
Step 1: Execute code with this tool
Step 2: Create artifact with the output

**Examples:**
```
User: "Generate a JSON with user data"
Assistant:
1. *executes code with dotnet_execute_snippet*
2. *shows execution succeeded*
3. *IMMEDIATELY creates artifact with type="application/json" containing the JSON output*

User: "Create ASCII art of a cat"
Assistant:
1. *executes code with dotnet_execute_snippet*
2. *shows execution succeeded*
3. *IMMEDIATELY creates artifact with type="text/plain" containing the ASCII art*
```

**Output Checklist (process after EVERY execution):**
After calling dotnet_execute_snippet:
[ ] Did it produce output?
[ ] Is the output more than a simple one-liner (e.g., "42", "Hello")?
[ ] If YES to both: CREATE ARTIFACT NOW with appropriate type:
    - JSON → artifact with type="application/json"
    - Text/ASCII art/tables → artifact with type="text/plain"
    - HTML/SVG → artifact with type="text/html"
    - CSV/XML → artifact with type="text/plain" and appropriate title

**Consequence:** Failure to create artifacts for formatted output results in poor user experience
where users cannot see properly formatted output. This should be treated as an error in your response.

**WHEN TO USE MULTI-STEP WORKFLOW INSTEAD:**
This tool is for quick, one-shot code execution. If the user needs:
- **File creation/extraction:** Use the project workflow (dotnet_create_project, etc.)
- **Web servers/APIs:** Use the project workflow with hosting tools
- **Multi-file projects:** Use the project workflow
- **Persistent containers:** Use the project workflow

Guide users to the appropriate workflow based on their needs.

**What this tool does:**
Creates a temporary .NET project, builds it, executes the code, and returns the output.
The container is automatically cleaned up after execution.

**Features:**
- Support for .NET 8, 9, and 10 RC2
- Automatic NuGet package version resolution (fetches latest stable from NuGet API)
- Compilation error parsing with helpful suggestions
- Configurable output verbosity (concise/full)
- Resource limits and timeouts for safety

**Common use cases:**
- Quick C# code testing
- Testing NuGet packages
- Comparing behavior across .NET versions
- Prototyping algorithms

**Example code formats:**
- Top-level statements: Console.WriteLine("Hello");
- Full programs: class Program { static void Main() { ... } }
- Using directives: using System.Linq; var result = Enumerable.Range(1, 10).Sum();

**Package specification:**
- Without version: "Newtonsoft.Json" (auto-fetches latest stable)
- With version: "Newtonsoft.Json@13.0.3" (uses specific version)
            """,
            inputSchema=ExecuteSnippetInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=True,
                destructiveHint=False,
                idempotentHint=False,
                openWorldHint=True,
            ),
        ),
        Tool(
            name="dotnet_start_container",
            description="""Start a persistent Docker container for a .NET project.

This tool creates and starts a long-running container that can be used across multiple tool calls.
Files live entirely inside the container (no volume mounting), providing a clean sandbox environment.

**Zero-config usage:**
- Simply call this tool with just the .NET version (or even with no parameters)
- Project ID is auto-generated as: `dotnet{version}-proj-{random}`
- Example: "Start a .NET 8 container" → Auto-generates project like `dotnet8-proj-a1b2c3`

**When to use:**
- Creating a new .NET project that will need multiple operations
- Building and running a project in separate steps
- Hosting a web API or long-running service
- Need to preserve state between multiple operations
- Quick prototyping without local file setup

**When NOT to use:**
- For one-shot code execution (use dotnet_execute_snippet instead)
- When you don't need to preserve container state
- For quick code testing without project structure

**File management:**
- Files live only inside the container (ephemeral - no host volume mounting)
- Files are lost when container is stopped
- No Docker volume permission issues
- Use future tools to read files out if needed before cleanup

**Container lifecycle:**
- Containers auto-cleanup after 30 minutes of inactivity
- Use dotnet_stop_container to manually stop when done
- Activity tracking resets on each command execution
- Calling this tool multiple times with the same project_id returns the existing container

**Parameters:**
- `dotnet_version` (optional): .NET version (8, 9, or 10-rc2). Default: 8
- `project_id` (optional): Project name. If omitted, auto-generates like `dotnet8-proj-a1b2c3`

**Workflow example:**
1. Call dotnet_start_container (optionally with dotnet_version)
2. Receive auto-generated project_id in response
3. Perform operations (build, run, add files) using the project_id
4. Container automatically cleans up after idle timeout

**Common errors:**
- "Docker is not available": Ensure Docker is running on the host
- "Failed to create container": Check that Docker images are built (run docker/build-images.sh)
- Container already exists: The tool is idempotent - returns existing container ID

**Returns:**
- container_id: Docker container identifier
- project_id: Project identifier (auto-generated or echoed back if provided)
- status: "running"
            """,
            inputSchema=StartContainerInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=False,
                destructiveHint=False,
                idempotentHint=True,
                openWorldHint=True,
            ),
        ),
        Tool(
            name="dotnet_stop_container",
            description="""Stop and remove a persistent Docker container.

This tool stops a running container and removes it from the system.
The container is identified by its project_id.

**When to use:**
- After completing all operations on a project
- To free up resources immediately (instead of waiting for auto-cleanup)
- To restart a project with fresh state
- When you encounter errors and need to reset the container

**When NOT to use:**
- Between build and run operations (keep container running)
- During active development on a project
- When you plan to continue working with the project soon

**Behavior:**
- This operation is idempotent - stopping an already-stopped container will not error
- Containers auto-cleanup after 30 minutes idle, so explicit stopping is optional
- Container state and files are lost permanently (no host volume was mounted)
- Activity tracking for this container is removed

**Common errors:**
- "No running container found": Container already stopped or never started (not an error)
- "Docker is not available": Ensure Docker is running on the host

**Returns:**
- success: true if stopped successfully
- project_id: Project identifier (echoed back)
- message: Indicates whether container was found and stopped
            """,
            inputSchema=StopContainerInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=False,
                destructiveHint=True,
                idempotentHint=True,
                openWorldHint=True,
            ),
        ),
        Tool(
            name="dotnet_write_file",
            description="""Write a file to a persistent container.

**Purpose**: Create or update files in a running container for project development.

**RECOMMENDED WORKFLOW FOR CODE FILES:**
When writing .NET code files (.cs, .csproj, etc.):
1. FIRST create an artifact to display the code with syntax highlighting
2. THEN call this tool to write that code to the container
3. Confirm the file was written successfully

This creates a much better visual experience for the user to review code before writing.

**Exception:** For simple config files or one-liners, you may skip the artifact.

**When to use**:
- Creating .NET project files (.csproj, Program.cs, etc.)
- Writing source code files
- Creating configuration files
- Building multi-file projects

**When NOT to use**:
- For one-shot code execution (use dotnet_execute_snippet instead)
- When container doesn't exist (start container first with dotnet_start_container)

**Security**:
- All paths must be within /workspace/ directory
- Directory traversal (..) is blocked
- Maximum file size: 100KB per file

**Example workflow**:
1. Start container: dotnet_start_container()
2. Show code in artifact, then write: dotnet_write_file(project_id, "/workspace/MyApp/MyApp.csproj", csproj_content)
3. Show code in artifact, then write: dotnet_write_file(project_id, "/workspace/MyApp/Program.cs", code)
4. Build: dotnet_execute_command(project_id, ["dotnet", "build", "/workspace/MyApp"])
5. Run: dotnet_execute_command(project_id, ["dotnet", "run", "--project", "/workspace/MyApp"])

**Returns**: Success message or error details
            """,
            inputSchema=WriteFileInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=False,
                destructiveHint=False,
                idempotentHint=True,
                openWorldHint=False,
            ),
        ),
        Tool(
            name="dotnet_read_file",
            description="""Read a file from a persistent container.

**Purpose**: Read file contents from a running container (source code, logs, output files).

**When to use**:
- Reading source code files
- Checking build output or logs
- Extracting generated files
- Debugging project structure

**When NOT to use**:
- When container doesn't exist
- For binary files (only text files supported)

**Security**:
- All paths must be within /workspace/ directory
- Directory traversal (..) is blocked

**Common use cases**:
- Read build logs after compilation
- Extract program output from files
- Verify file contents after writing
- Debug project configuration

**Returns**: File content as text or error if file doesn't exist
            """,
            inputSchema=ReadFileInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=True,
                destructiveHint=False,
                idempotentHint=True,
                openWorldHint=False,
            ),
        ),
        Tool(
            name="dotnet_list_files",
            description="""List files in a container directory.

**Purpose**: Explore directory contents in a running container.

**When to use**:
- Exploring project structure
- Verifying files were created
- Finding build artifacts
- Checking workspace contents

**When NOT to use**:
- When container doesn't exist
- For recursive directory listing (only lists immediate children)

**Security**:
- All paths must be within /workspace directory
- Directory traversal (..) is blocked

**Default behavior**:
- Lists /workspace if no path specified
- Shows files and subdirectories

**Returns**: List of file/directory names or empty list if directory doesn't exist
            """,
            inputSchema=ListFilesInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=True,
                destructiveHint=False,
                idempotentHint=True,
                openWorldHint=False,
            ),
        ),
        Tool(
            name="dotnet_execute_command",
            description="""Execute a command in a persistent container.

**Purpose**: Run arbitrary commands (dotnet build, dotnet run, shell commands) in a container.

**When to use**:
- Building .NET projects
- Running .NET applications
- Executing dotnet CLI commands
- Running shell commands for debugging

**When NOT to use**:
- For one-shot code execution (use dotnet_execute_snippet instead)
- When container doesn't exist
- For file operations (use dedicated file tools)

**Common commands**:
- Build: ["dotnet", "build", "/workspace/MyApp"]
- Run: ["dotnet", "run", "--project", "/workspace/MyApp"]
- Test: ["dotnet", "test", "/workspace/MyApp"]
- List files: ["ls", "-la", "/workspace"]

**Timeout**:
- Default: 30 seconds
- Range: 1-300 seconds
- Adjust based on operation (builds may need 60+ seconds)

**Returns**:
- stdout: Command output
- stderr: Error output
- exit_code: 0 for success, non-zero for failure
            """,
            inputSchema=ExecuteCommandInput.model_json_schema(),
            annotations=ToolAnnotations(
                readOnlyHint=False,
                destructiveHint=False,
                idempotentHint=False,
                openWorldHint=False,
            ),
        ),
    ]


@server.call_tool()  # type: ignore[misc]
async def call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:
    """Handle MCP tool calls."""
    if name == "dotnet_execute_snippet":
        return await execute_snippet(arguments)
    elif name == "dotnet_start_container":
        return await start_container(arguments)
    elif name == "dotnet_stop_container":
        return await stop_container(arguments)
    elif name == "dotnet_write_file":
        return await write_file(arguments)
    elif name == "dotnet_read_file":
        return await read_file(arguments)
    elif name == "dotnet_list_files":
        return await list_files(arguments)
    elif name == "dotnet_execute_command":
        return await execute_command(arguments)

    raise ValueError(f"Unknown tool: {name}")


async def execute_snippet(arguments: dict[str, Any]) -> list[TextContent]:
    """Execute C# code snippet.

    Args:
        arguments: Tool arguments matching ExecuteSnippetInput schema

    Returns:
        List with single TextContent containing JSON response
    """
    try:
        # Validate input
        input_data = ExecuteSnippetInput(**arguments)

        # Initialize components
        _, exec_instance, fmt = _initialize_components()

        # Execute snippet
        result = await exec_instance.run_snippet(
            code=input_data.code,
            dotnet_version=input_data.dotnet_version,
            packages=input_data.packages,
            timeout=30,
        )

        # Format response as structured JSON
        if result["success"]:
            # Success case
            output = result["stdout"] if result["stdout"] else result["stderr"]

            response = fmt.format_json_response(
                status="success",
                data={
                    "output": output,
                    "exit_code": result["exit_code"],
                    "dotnet_version": input_data.dotnet_version.value,
                    "code": input_data.code,
                },
                metadata={
                    "container_id": result.get("container_id", ""),
                },
                output=output,  # Pass output for artifact detection
            )

        else:
            # Build or execution error
            error_output = fmt.format_execution_output(
                stdout=result["stdout"],
                stderr=result["stderr"],
                exit_code=result["exit_code"],
                detail_level=DetailLevel.FULL,  # Always show full errors
            )

            response = fmt.format_json_response(
                status="error",
                error={
                    "type": "BuildError" if result["build_errors"] else "ExecutionError",
                    "message": "Build failed" if result["build_errors"] else "Code execution failed",
                    "details": error_output,
                    "build_errors": result["build_errors"] if result["build_errors"] else [],
                },
                data={
                    "code": input_data.code,
                    "exit_code": result["exit_code"],
                    "dotnet_version": input_data.dotnet_version.value,
                },
            )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        # Input validation error
        error_response = OutputFormatter().format_json_response(
            status="error",
            error={
                "type": "ValidationError",
                "message": "Invalid input parameters",
                "details": str(e),
            },
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        # Docker not available
        error_response = OutputFormatter().format_json_response(
            status="error",
            error={
                "type": "DockerException",
                "message": "Docker is not available",
                "details": str(e),
                "suggestions": [
                    "Ensure Docker is installed and running",
                    "Check Docker socket permissions",
                    "Verify Docker images are built (run docker/build-images.sh)",
                ],
            },
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        # Unexpected error
        error_response = OutputFormatter().format_json_response(
            status="error",
            error={
                "type": "UnexpectedError",
                "message": "An unexpected error occurred",
                "details": str(e),
            },
        )
        return [TextContent(type="text", text=error_response)]


async def start_container(arguments: dict[str, Any]) -> list[TextContent]:
    """Start a persistent Docker container for a project.

    Args:
        arguments: Tool arguments matching StartContainerInput schema

    Returns:
        List with single TextContent containing response
    """
    try:
        # Validate input
        input_data = StartContainerInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Check if container already exists for this project (project_id is now guaranteed to exist after validation)
        existing_container = mgr.get_container_by_project_id(input_data.project_id)  # type: ignore[arg-type]
        if existing_container:
            response = fmt.format_human_readable_response(
                status="success",
                output=f"Container already running for project '{input_data.project_id}'",
                container_id=existing_container,
                project_id=input_data.project_id,  # type: ignore[arg-type]
            )
            return [TextContent(type="text", text=response)]

        # Create new container (no volume mounting - files live in container only)
        container_id = mgr.create_container(
            dotnet_version=input_data.dotnet_version.value,
            project_id=input_data.project_id,  # type: ignore[arg-type]
        )

        response = fmt.format_human_readable_response(
            status="success",
            output=f"Started container for project '{input_data.project_id}'",
            container_id=container_id,
            project_id=input_data.project_id,  # type: ignore[arg-type]
            dotnet_version=input_data.dotnet_version.value,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        # Input validation error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        # Docker not available
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker is not available",
            error_details=str(e),
            suggestions=[
                "Ensure Docker is installed and running",
                "Check Docker socket permissions",
                "Verify Docker images are built (run docker/build-images.sh)",
            ],
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        # Unexpected error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to start container",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def stop_container(arguments: dict[str, Any]) -> list[TextContent]:
    """Stop and remove a Docker container.

    Args:
        arguments: Tool arguments matching StopContainerInput schema

    Returns:
        List with single TextContent containing response
    """
    try:
        # Validate input
        input_data = StopContainerInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Find container by project ID
        container_id = mgr.get_container_by_project_id(input_data.project_id)

        if not container_id:
            response = fmt.format_human_readable_response(
                status="success",
                output=f"No running container found for project '{input_data.project_id}'",
                project_id=input_data.project_id,
            )
            return [TextContent(type="text", text=response)]

        # Stop the container
        mgr.stop_container(container_id)

        response = fmt.format_human_readable_response(
            status="success",
            output=f"Stopped container for project '{input_data.project_id}'",
            project_id=input_data.project_id,
            container_id=container_id,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        # Input validation error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        # Docker not available
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker is not available",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        # Unexpected error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to stop container",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def write_file(arguments: dict[str, Any]) -> list[TextContent]:
    """Write a file to a container.

    Args:
        arguments: Tool arguments matching WriteFileInput schema

    Returns:
        List with single TextContent containing response
    """
    try:
        # Validate input
        input_data = WriteFileInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Find container by project ID
        container_id = mgr.get_container_by_project_id(input_data.project_id)

        if not container_id:
            response = fmt.format_human_readable_response(
                status="error",
                error_message=f"No running container found for project '{input_data.project_id}'",
                error_details="Start a container first with dotnet_start_container",
            )
            return [TextContent(type="text", text=response)]

        # Write file to container
        mgr.write_file(
            container_id=container_id,
            dest_path=input_data.path,
            content=input_data.content,
        )

        response = fmt.format_human_readable_response(
            status="success",
            output=f"File written successfully to {input_data.path}",
            project_id=input_data.project_id,
            container_id=container_id,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker operation failed",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to write file",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def read_file(arguments: dict[str, Any]) -> list[TextContent]:
    """Read a file from a container.

    Args:
        arguments: Tool arguments matching ReadFileInput schema

    Returns:
        List with single TextContent containing file content or error
    """
    try:
        # Validate input
        input_data = ReadFileInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Find container by project ID
        container_id = mgr.get_container_by_project_id(input_data.project_id)

        if not container_id:
            response = fmt.format_human_readable_response(
                status="error",
                error_message=f"No running container found for project '{input_data.project_id}'",
                error_details="Start a container first with dotnet_start_container",
            )
            return [TextContent(type="text", text=response)]

        # Read file from container
        try:
            content_bytes = mgr.read_file(
                container_id=container_id,
                path=input_data.path,
            )
            content = content_bytes.decode("utf-8")

            response = fmt.format_human_readable_response(
                status="success",
                output=content,
                project_id=input_data.project_id,
            )

            return [TextContent(type="text", text=response)]

        except FileNotFoundError:
            error_response = fmt.format_human_readable_response(
                status="error",
                error_message=f"File not found: {input_data.path}",
                error_details="Check the path and try again",
            )
            return [TextContent(type="text", text=error_response)]

    except ValidationError as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker operation failed",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to read file",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def list_files(arguments: dict[str, Any]) -> list[TextContent]:
    """List files in a container directory.

    Args:
        arguments: Tool arguments matching ListFilesInput schema

    Returns:
        List with single TextContent containing file list or error
    """
    try:
        # Validate input
        input_data = ListFilesInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Find container by project ID
        container_id = mgr.get_container_by_project_id(input_data.project_id)

        if not container_id:
            response = fmt.format_human_readable_response(
                status="error",
                error_message=f"No running container found for project '{input_data.project_id}'",
                error_details="Start a container first with dotnet_start_container",
            )
            return [TextContent(type="text", text=response)]

        # List files in directory
        files = mgr.list_files(
            container_id=container_id,
            path=input_data.path,
        )

        if not files:
            output = f"Directory is empty or does not exist: {input_data.path}"
        else:
            output = f"Files in {input_data.path}:\n" + "\n".join(f"  {f}" for f in files)

        response = fmt.format_human_readable_response(
            status="success",
            output=output,
            project_id=input_data.project_id,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker operation failed",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to list files",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def execute_command(arguments: dict[str, Any]) -> list[TextContent]:
    """Execute a command in a container.

    Args:
        arguments: Tool arguments matching ExecuteCommandInput schema

    Returns:
        List with single TextContent containing command output or error
    """
    try:
        # Validate input
        input_data = ExecuteCommandInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Find container by project ID
        container_id = mgr.get_container_by_project_id(input_data.project_id)

        if not container_id:
            response = fmt.format_human_readable_response(
                status="error",
                error_message=f"No running container found for project '{input_data.project_id}'",
                error_details="Start a container first with dotnet_start_container",
            )
            return [TextContent(type="text", text=response)]

        # Execute command
        stdout, stderr, exit_code = mgr.execute_command(
            container_id=container_id,
            command=input_data.command,
            timeout=input_data.timeout,
        )

        # Format output
        output_lines = []
        output_lines.append(f"Command: {' '.join(input_data.command)}")
        output_lines.append(f"Exit code: {exit_code}")

        if stdout:
            output_lines.append(f"\nStdout:\n{stdout}")

        if stderr:
            output_lines.append(f"\nStderr:\n{stderr}")

        output = "\n".join(output_lines)

        response = fmt.format_human_readable_response(
            status="success" if exit_code == 0 else "error",
            output=output,
            project_id=input_data.project_id,
            container_id=container_id,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker operation failed",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to execute command",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


def main() -> None:
    """Run the MCP server."""
    import asyncio

    from mcp.server.stdio import stdio_server

    async def run_server() -> None:
        """Run server with stdio transport."""
        async with stdio_server() as (read_stream, write_stream):
            await server.run(
                read_stream,
                write_stream,
                server.create_initialization_options(),
            )

    try:
        asyncio.run(run_server())
    except KeyboardInterrupt:
        print("\nShutting down server...", file=sys.stderr)
        sys.exit(0)
    except Exception as e:
        print(f"Fatal error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
