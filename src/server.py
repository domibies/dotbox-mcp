"""FastMCP server for .NET code execution in Docker containers."""

import sys
from typing import Any

from docker.errors import DockerException
from mcp.server import Server
from mcp.types import TextContent, Tool
from pydantic import ValidationError

from src.docker_manager import DockerContainerManager
from src.executor import DotNetExecutor
from src.formatter import OutputFormatter
from src.models import DetailLevel, ExecuteSnippetInput, StartContainerInput, StopContainerInput

# Initialize MCP server
server = Server("dotbox-mcp")

# Initialize components (will be created on first use)
docker_manager: DockerContainerManager | None = None
executor: DotNetExecutor | None = None
formatter: OutputFormatter | None = None


def _initialize_components() -> tuple[DockerContainerManager, DotNetExecutor, OutputFormatter]:
    """Initialize Docker manager, executor, and formatter.

    Returns:
        Tuple of (docker_manager, executor, formatter)

    Raises:
        DockerException: If Docker is not available
    """
    global docker_manager, executor, formatter

    if docker_manager is None:
        docker_manager = DockerContainerManager()

    if executor is None:
        executor = DotNetExecutor(docker_manager=docker_manager)

    if formatter is None:
        formatter = OutputFormatter()

    return docker_manager, executor, formatter


@server.list_tools()  # type: ignore[misc, no-untyped-call]
async def list_tools() -> list[Tool]:
    """List available MCP tools."""
    # Perform lazy cleanup on every tool invocation
    if docker_manager is not None:
        docker_manager._lazy_cleanup(idle_timeout_minutes=30)

    return [
        Tool(
            name="dotnet_execute_snippet",
            description="""Execute a C# code snippet in an isolated Docker container.

**RECOMMENDED WORKFLOW FOR BEST USER EXPERIENCE:**
When executing C# code (whether provided by the user or generated by the assistant):
1. FIRST create a C# code artifact to display the code cleanly with syntax highlighting
2. THEN call this tool to execute that code
3. Show the execution results

This creates a much better visual experience compared to showing code only in the tool call or execution output.

**Exception:** For very simple one-liners (like `Console.WriteLine("Hello");`), you may skip the artifact and execute directly.

**OUTPUT VISUALIZATION - REQUIRED:**
After executing code, you MUST create an artifact for the output:
- **JSON output:** ALWAYS create an artifact with JSON syntax highlighting
- **Text output:** ALWAYS create a text artifact (preserves formatting, ASCII art, tables, etc.)
- **HTML/SVG output:** ALWAYS create an HTML artifact to render it
- **Structured data (CSV, XML, etc.):** ALWAYS use appropriate syntax highlighting in artifacts

Exception: Simple single-line outputs (like "42" or "Hello World") don't need artifacts.

This is not optional - artifacts ensure proper formatting and user experience.

**WHEN TO USE MULTI-STEP WORKFLOW INSTEAD:**
This tool is for quick, one-shot code execution. If the user needs:
- **File creation/extraction:** Use the project workflow (dotnet_create_project, etc.)
- **Web servers/APIs:** Use the project workflow with hosting tools
- **Multi-file projects:** Use the project workflow
- **Persistent containers:** Use the project workflow

Guide users to the appropriate workflow based on their needs.

**What this tool does:**
Creates a temporary .NET project, builds it, executes the code, and returns the output.
The container is automatically cleaned up after execution.

**Features:**
- Support for .NET 8, 9, and 10 RC2
- Automatic NuGet package version resolution (fetches latest stable from NuGet API)
- Compilation error parsing with helpful suggestions
- Configurable output verbosity (concise/full)
- Resource limits and timeouts for safety

**Common use cases:**
- Quick C# code testing
- Testing NuGet packages
- Comparing behavior across .NET versions
- Prototyping algorithms

**Example code formats:**
- Top-level statements: Console.WriteLine("Hello");
- Full programs: class Program { static void Main() { ... } }
- Using directives: using System.Linq; var result = Enumerable.Range(1, 10).Sum();

**Package specification:**
- Without version: "Newtonsoft.Json" (auto-fetches latest stable)
- With version: "Newtonsoft.Json@13.0.3" (uses specific version)
            """,
            inputSchema=ExecuteSnippetInput.model_json_schema(),
        ),
        Tool(
            name="dotnet_start_container",
            description="""Start a persistent Docker container for a .NET project.

This tool creates and starts a long-running container that can be used across multiple tool calls.
Use this when you need to perform multiple operations (build, run, add files) on the same project.

**When to use:**
- Creating a new .NET project that will need multiple operations
- Building and running a project in separate steps
- Hosting a web API or long-running service

**Container lifecycle:**
- Containers auto-cleanup after 30 minutes of inactivity
- Use dotnet_stop_container to manually stop when done
- Activity tracking resets on each command execution

**Workflow example:**
1. Call dotnet_start_container with project_id and working_dir
2. Perform operations (build, run, add files) using the project_id
3. Container automatically cleans up after idle timeout

**Returns:**
- container_id: Docker container identifier
- project_id: Project identifier (echoed back)
- status: "running"
            """,
            inputSchema=StartContainerInput.model_json_schema(),
        ),
        Tool(
            name="dotnet_stop_container",
            description="""Stop and remove a persistent Docker container.

This tool stops a running container and removes it from the system.
The container is identified by its project_id.

**When to use:**
- After completing all operations on a project
- To free up resources immediately (instead of waiting for auto-cleanup)
- To restart a project with fresh state

**Note:**
- This operation is idempotent - stopping an already-stopped container will not error
- Containers auto-cleanup after 30 minutes idle, so explicit stopping is optional

**Returns:**
- success: true if stopped successfully
- project_id: Project identifier (echoed back)
            """,
            inputSchema=StopContainerInput.model_json_schema(),
        ),
    ]


@server.call_tool()  # type: ignore[misc]
async def call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:
    """Handle MCP tool calls."""
    if name == "dotnet_execute_snippet":
        return await execute_snippet(arguments)
    elif name == "dotnet_start_container":
        return await start_container(arguments)
    elif name == "dotnet_stop_container":
        return await stop_container(arguments)

    raise ValueError(f"Unknown tool: {name}")


async def execute_snippet(arguments: dict[str, Any]) -> list[TextContent]:
    """Execute C# code snippet.

    Args:
        arguments: Tool arguments matching ExecuteSnippetInput schema

    Returns:
        List with single TextContent containing JSON response
    """
    try:
        # Validate input
        input_data = ExecuteSnippetInput(**arguments)

        # Initialize components
        _, exec_instance, fmt = _initialize_components()

        # Execute snippet
        result = await exec_instance.run_snippet(
            code=input_data.code,
            dotnet_version=input_data.dotnet_version,
            packages=input_data.packages,
            timeout=30,
        )

        # Format response in human-readable format
        if result["success"]:
            # Success case
            output = result["stdout"] if result["stdout"] else result["stderr"]

            response = fmt.format_human_readable_response(
                status="success",
                output=output,
                exit_code=result["exit_code"],
                dotnet_version=input_data.dotnet_version.value,
                code=input_data.code,  # Include the code that was executed
            )

        else:
            # Build or execution error
            error_output = fmt.format_execution_output(
                stdout=result["stdout"],
                stderr=result["stderr"],
                exit_code=result["exit_code"],
                detail_level=DetailLevel.FULL,  # Always show full errors
            )

            response = fmt.format_human_readable_response(
                status="error",
                error_message="Code execution failed"
                if not result["build_errors"]
                else "Build failed",
                error_details=error_output,
                build_errors=result["build_errors"],
                dotnet_version=input_data.dotnet_version.value,
                code=input_data.code,  # Include the code that failed
            )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        # Input validation error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        # Docker not available
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker is not available",
            error_details=str(e),
            suggestions=[
                "Ensure Docker is installed and running",
                "Check Docker socket permissions",
                "Verify Docker images are built (run docker/build-images.sh)",
            ],
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        # Unexpected error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="An unexpected error occurred",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def start_container(arguments: dict[str, Any]) -> list[TextContent]:
    """Start a persistent Docker container for a project.

    Args:
        arguments: Tool arguments matching StartContainerInput schema

    Returns:
        List with single TextContent containing response
    """
    try:
        # Validate input
        input_data = StartContainerInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Check if container already exists for this project
        existing_container = mgr.get_container_by_project_id(input_data.project_id)
        if existing_container:
            response = fmt.format_human_readable_response(
                status="success",
                output=f"Container already running for project '{input_data.project_id}'",
                container_id=existing_container,
                project_id=input_data.project_id,
            )
            return [TextContent(type="text", text=response)]

        # Create new container
        container_id = mgr.create_container(
            dotnet_version=input_data.dotnet_version.value,
            project_id=input_data.project_id,
            working_dir=input_data.working_dir,
        )

        response = fmt.format_human_readable_response(
            status="success",
            output=f"Started container for project '{input_data.project_id}'",
            container_id=container_id,
            project_id=input_data.project_id,
            dotnet_version=input_data.dotnet_version.value,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        # Input validation error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        # Docker not available
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker is not available",
            error_details=str(e),
            suggestions=[
                "Ensure Docker is installed and running",
                "Check Docker socket permissions",
                "Verify Docker images are built (run docker/build-images.sh)",
            ],
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        # Unexpected error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to start container",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


async def stop_container(arguments: dict[str, Any]) -> list[TextContent]:
    """Stop and remove a Docker container.

    Args:
        arguments: Tool arguments matching StopContainerInput schema

    Returns:
        List with single TextContent containing response
    """
    try:
        # Validate input
        input_data = StopContainerInput(**arguments)

        # Initialize components
        mgr, _, fmt = _initialize_components()

        # Find container by project ID
        container_id = mgr.get_container_by_project_id(input_data.project_id)

        if not container_id:
            response = fmt.format_human_readable_response(
                status="success",
                output=f"No running container found for project '{input_data.project_id}'",
                project_id=input_data.project_id,
            )
            return [TextContent(type="text", text=response)]

        # Stop the container
        mgr.stop_container(container_id)

        response = fmt.format_human_readable_response(
            status="success",
            output=f"Stopped container for project '{input_data.project_id}'",
            project_id=input_data.project_id,
            container_id=container_id,
        )

        return [TextContent(type="text", text=response)]

    except ValidationError as e:
        # Input validation error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Invalid input parameters",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except DockerException as e:
        # Docker not available
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Docker is not available",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]

    except Exception as e:
        # Unexpected error
        error_response = OutputFormatter().format_human_readable_response(
            status="error",
            error_message="Failed to stop container",
            error_details=str(e),
        )
        return [TextContent(type="text", text=error_response)]


def main() -> None:
    """Run the MCP server."""
    import asyncio

    from mcp.server.stdio import stdio_server

    async def run_server() -> None:
        """Run server with stdio transport."""
        async with stdio_server() as (read_stream, write_stream):
            await server.run(
                read_stream,
                write_stream,
                server.create_initialization_options(),
            )

    try:
        asyncio.run(run_server())
    except KeyboardInterrupt:
        print("\nShutting down server...", file=sys.stderr)
        sys.exit(0)
    except Exception as e:
        print(f"Fatal error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
